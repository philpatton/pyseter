{
  "hash": "2ad164c5b00e0f7f15c820d9f56a6115",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Grading distinctiveness\nbibliography: references.bib\njupyter:\n  kernelspec:\n    display_name: Python (Pyseter)\n    language: python\n    name: pyseter_env\n---\n\nPyseter comes with an experimental algorithm for grading individual distinctiveness. This can be useful for partially marked populations, e.g., spinner dolphins. \n\n## Background\n\nTo understand the distinctiveness algorithm, it can be helpful to first introduce one of Pyseter’s clustering algorithms, `NetworkCluster`. Network clustering works with similarity scores, which represent the similarity between two individuals in a pair of images. We can define a threshold score, the `match_threshold`, above which we consider two individuals to be the same. That is, if the similarity score between two images is above a certain threshold, we cluster them into a proposed ID. As such, network clustering works by treating the query set as a network, where the nodes are images and the edges are similarity scores above a threshold. Each set of connected components, i.e., images whose similarity scores are above the match threshold, represents a proposed ID.\n\nWe might expect the indistinct individuals to cluster together. In the context of facial recognition, @deng-2023-ui observed that “unrecognizable identities”, e.g., extremely blurry or masked faces, tend to cluster together. As such, for partially marked populations, the largest cluster in the query set may represent every indistinct individual. Following @deng-2023-ui, we can compute the average feature vector for this cluster. The distance between this average feature vector and the feature vector for each image is the distinctiveness score for that image. As such, the score applies to the image, not the animal. To get a score for an animal, users could average the distinctiveness scores across images for that animal.\n\n## Spinner dolphin example\n\nThe images in this example were collected during a multi-year photo-ID survey of spinner dolphins in Hawaiʻi. We'll load in the saved feature vectors from before. \n\n::: {#d487ed54 .cell execution_count=1}\n``` {.python .cell-code}\n%config InlineBackend.figure_format = 'retina'\n\nfrom pyseter.grade import rate_distinctiveness\nfrom pyseter.sort import load_features\nfrom sklearn.metrics import roc_curve, RocCurveDisplay, roc_auc_score\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# load the features\nfeature_dir = 'working_dir/features'\nout_path = feature_dir + '/features.npy'\nfilenames, feature_array = load_features(out_path)\n```\n:::\n\n\nWe need to supply two arguments to `rate_distinctiveness`: the `feature_array`, and the `match_threshold`. The lower the match threshold, the more individuals will end up in the unrecognizable identity cluster, potentially including distinct individuals. Conversely, a high match threshold might split the indistinct individuals into many clusters. \n\n::: {#5984ca6f .cell execution_count=2}\n``` {.python .cell-code}\ndistinctiveness = rate_distinctiveness(feature_array, match_threshold=0.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nUnrecognizable identity cluster consists of 196 images.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n/Users/PattonP/miniforge3/envs/pyseter_env/lib/python3.14/site-packages/pyseter/grade.py:35: UserWarning: Distinctiveness grades are experimental and should be verified.\n  warn(UserWarning('Distinctiveness grades are experimental and should be verified.'))\n```\n:::\n:::\n\n\n`rate_distinctiveness` warns you that this is experimental, and lets you know how many individuals ended up in the unrecognizable identity. This should be a quick sanity check. \n\nWe can plot the results of the score with the receiver operator characteristic (ROC) curve. This treats the distinctiveness grade as a classifier probability. The area under the curve tells us how good the classifier is, i.e., in terms of the number of false positives and false negatives. \n\n::: {#b33f8cfe .cell execution_count=3}\n``` {.python .cell-code}\n# download the true distinctiveness scores\ndata_url = (\n    'https://raw.githubusercontent.com/philpatton/pyseter/main/' \n    'data/spinner-distinct.csv'\n)\nspinner_distinct = pd.read_csv(data_url)\n\n# merge with the predicted distinctiveness scores\ners_df = pd.DataFrame({'image': filenames, 'ers': 1 - distinctiveness})\ners_df = ers_df.merge(spinner_distinct)\n\n# compute the curve first, which will get displayed\ny_score = ers_df['ers']\ny_test, _ = ers_df.distinctiveness.factorize()\nfpr, tpr, _ = roc_curve(y_test, y_score)\n\nfig, ax = plt.subplots()\n\nroc_display = RocCurveDisplay(fpr=fpr, tpr=tpr).plot(ax=ax)\nax.spines['right'].set_visible(False)\nax.spines['top'].set_visible(False)\n\nroc_auc = roc_auc_score(y_test, y_score)\nax.text(0.95, 0.6, f'AUC={roc_auc:0.3f}', ha='right', va='top')\nimport numpy as np\nax.plot(np.arange(0, 1.1, 0.1), np.arange(0, 1.1, 0.1), linestyle='--', c='tab:grey')\nax.set_title('ROC Curve for \\nDistinctiveness Classifier')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](distinct_files/figure-html/cell-4-output-1.png){width=445 height=467}\n:::\n:::\n\n\nWe can see that, for this example, the distinctiveness score is better than useless (gray dashed line).\n\n",
    "supporting": [
      "distinct_files"
    ],
    "filters": [],
    "includes": {}
  }
}